Crusty TTS – Architecture Planning Document 1. Vision Crusty TTS is designed as a headless, modular runtime for declarative audio synthesis pipelines. It is not a GUI application. It is infrastructure: a plugin-driven orchestration engine that can be invoked via CLI or accessed through a daemon API. 2. Core Architecture crusty-core (library crate): • Plugin registry and manifest parsing • Capability graph and validation engine • Orchestration (.cr) parser and validator • Pipeline executor (stream-based) • Security verification and isolation hooks crusty-cli (thin binary): • Executes orchestration files • Streams output to file or stdout • Stateless, deterministic execution crusty-daemon (thin binary): • Loads plugins at startup • Exposes REST or gRPC API
 Manages job lifecycle (IDs, status, cancellation) • Streams execution output 3. Execution Model A single shared execution function powers both CLI and daemon modes. Pipelines are defined declaratively via orchestration files and executed as streams. No mode-specific branching logic exists inside crusty-core. 4. Orchestration (.cr) The .cr file defines portable pipeline configurations. It specifies plugin sequence, configuration parameters, and data flow. The API may accept JSON that serializes to .cr format, ensuring portability across interfaces. 5. Plugin System Plugins declare capabilities through manifest files. These include supported input/output types, configuration options, and constraints. The core validates compatibility before execution. Plugins remain unaware of runtime mode (CLI or daemon). 6. API Design The daemon exposes endpoints to list plugins, retrieve capabilities, validate pipelines, execute jobs, stream results, and query job status. REST is recommended initially for simplicity. All UI layers consume this API rather than interacting with plugins directly. 7. Design Principles • Headless core with clean separation of concerns • Stateless execution by default
  Stream-first design to avoid buffering inconsistencies • Deterministic validation before execution • Minimal v1 scope: linear pipelines only • Cross-language plugin compatibility 8. Future Extensions Potential expansions include branching pipelines, parallel execution nodes, distributed workers, and advanced sandboxing. These should be layered atop a stable, boring core.
