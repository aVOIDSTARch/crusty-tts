Crusty TTS â€“ Supplementary Architecture & Code Reference 1. Dual Runtime Modes Crusty supports both CLI and daemon execution. Both modes depend on a shared crusty-core library to ensure identical behavior and prevent logic divergence. 2. Project Structure crusty-core/    # Library crate (engine, registry, validation, execution) crusty-cli/     # Thin CLI wrapper crusty-daemon/  # Thin API wrapper 3. Shared Execution Function pub fn execute_pipeline(    orchestration: Orchestration,    input: InputStream ) -> Result<OutputStream> {    // 1. Validate orchestration    // 2. Resolve plugins    // 3. Build execution chain    // 4. Stream data through plugins } 4. CLI Mode Example crusty run orchestration.cr input.txt --output out.mp3 5. Daemon Mode Example crusty daemon --port 7420 GET  /plugins GET  /plugins/{id} POST /pipeline/validate POST /pipeline/run
GET  /jobs/{id}/status GET  /jobs/{id}/stream 6. Orchestration (.cr) Concept pipeline:  - plugin: text-cleaner    options:      normalize_whitespace: true  - plugin: tts-engine    options:      voice: "default"  - plugin: mp3-encoder    options:      bitrate: 192 7. Plugin Manifest Concept name = "tts-engine" version = "1.0.0" [capabilities] input = "text/plain" output = "audio/raw" [options.voice] type = "string" required = true 8. Design Constraints (v1 Scope) Version 1 is intentionally constrained to linear pipelines only. No branching graphs, no parallel execution nodes, and no distributed workers. Stream-first architecture is mandatory. Validation must occur before execution. 9. Long-Term Extensions Future work may include graph-based pipelines, distributed execution, plugin sandboxing policies, typed capability schemas, and automatic UI generation via JSON schema exposure.
